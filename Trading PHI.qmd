---
title: "Trading PHI"
format: html
editor: visual
---


```{r}
library(tidyverse)
```

```{r}

# Folder containing all your CSVs
folder_path <- "C:/Users/Parker Smith/Desktop/crypto/data 2"

# Get a list of all CSV files in the folder
files <- list.files(folder_path, pattern = "\\.csv$", full.names = TRUE)

# Read all CSVs and combine them into one data frame
exclude = c('USDT', 'USDC', 'WBTC')
crypto_data <- files %>%
  lapply(read.csv) %>%
  bind_rows() %>% 
  filter(!Symbol %in% exclude)
```

```{r}
crypto_wide <- crypto_data %>%
  select(Symbol, Date, Close) %>%          # Keep only relevant columns
  pivot_wider(
    names_from = Symbol,                   # Column names come from the coin symbol
    values_from = Close                    # Values come from the Close column
  ) %>%
  arrange(Date) %>% 
  drop_na()

crypto_wide$Date = as.Date(crypto_wide$Date)
```

Finding PHI for each coin
```{r}
auto_lm <- function(df, response, alpha = 0.05) {
  # start with all predictors except response and Date
  predictors <- setdiff(names(df), c(response, "Date"))
  
  formula <- as.formula(paste(response, "~", paste(predictors, collapse = " + "), "+ 0"))
  model <- lm(formula, data = df)
  
  repeat {
    pvals <- summary(model)$coefficients[, 4]  # no intercept anymore
    max_p <- max(pvals, na.rm = TRUE)
    
    if (max_p < alpha) break  # stop if all are significant
    
    worst_var <- names(which.max(pvals))
    predictors <- setdiff(predictors, worst_var)
    
    formula <- as.formula(paste(response, "~", paste(predictors, collapse = " + "), "+ 0"))
    model <- lm(formula, data = df)
  }
  
  return(model)
}

tickers = setdiff(colnames(crypto_wide), "Date")
all_PHI = data.frame(Date = crypto_wide$Date) # Start off with Dates
all_models = list()


for (i in tickers) {
  temp_model <- auto_lm(crypto_wide, i, alpha = 0.05)
  
  # Save residuals
  all_PHI[[i]] <- residuals(temp_model)
  
  # Save the full model
  all_models[[i]] <- temp_model
}
  
```

```{r}
# Check data
ggplot(all_PHI, aes(y = BTC, x = Date)) +
  geom_line() +
  geom_hline(yintercept = 0, color="blue")
```


Find AR model parameters
```{r}
coin_ticker = "BTC"

library(forecast)

fit <- auto.arima(all_PHI[[coin_ticker]], d = 0, max.p = 10, max.q = 0)

# Coefficients and standard errors
coefs <- fit$coef
se <- sqrt(diag(fit$var.coef))

# t-values and two-sided p-values
tvals <- coefs / se
pvals <- 2 * (1 - pnorm(abs(tvals)))

# Put in a tidy table
results <- data.frame(
  Estimate = coefs,
  Std.Error = se,
  t.value = tvals,
  p.value = pvals
)

results

```
Back test for specific coin from 2020-10-5 to 2021-07-06
```{r}
# Put PHI and Price data in the same df
trading_df = cbind(crypto_wide, PHI = all_PHI[[coin_ticker]])
model = all_models[[coin_ticker]]

starting_money = 1000
balance = c(starting_money)
sigma_2 = fit$sigma2
lambda = fit$coef
coin_coef = model$coefficients
coin_coef[[coin_ticker]] = 1
  
for (i in 1:(nrow(trading_df)-1)) { # -1 because you cant trade on last day
  day_data = trading_df[i, ]
  phi = day_data$PHI
  
  position_fraction = (1-lambda)*abs(phi)*phi / ( (1-lambda)^2*phi^2+sigma_2 ) # calculated based on E[ln(1-pi)] estimate, not correct
  
  position_value = position_fraction * tail(balance, 1)
  
  cost = 0
  for (j in names(coin_coef)) {
    cost = cost + as.numeric(day_data[j] * abs(coin_coef[j]))
  }
  
  #TODO Calc how much to buy of each coin using cost, position size, and balance
  
}
```

#TODO find best position size, previous method uses return of residual not of my investment, which it should.










