---
title: "Trading PHI"
format: html
editor: visual
---


```{r}
library(tidyverse)
library(forecast)
```

```{r}

# Folder containing all your CSVs
folder_path <- "C:/Users/Parker Smith/Desktop/crypto/data 2"

# Get a list of all CSV files in the folder
files <- list.files(folder_path, pattern = "\\.csv$", full.names = TRUE)

# Read all CSVs and combine them into one data frame
exclude = c('USDT', 'USDC', 'WBTC')
crypto_data <- files %>%
  lapply(read.csv) %>%
  bind_rows() %>% 
  filter(!Symbol %in% exclude)
```

```{r}
crypto_wide <- crypto_data %>%
  select(Symbol, Date, Close) %>%          # Keep only relevant columns
  pivot_wider(
    names_from = Symbol,                   # Column names come from the coin symbol
    values_from = Close                    # Values come from the Close column
  ) %>%
  arrange(Date) %>% 
  drop_na()

crypto_wide$Date = as.Date(crypto_wide$Date)

n <- nrow(crypto_wide)
split <- floor(0.8 * n)   # 80% train

train <- crypto_wide[1:split, ]
test  <- crypto_wide[(split+1):n, ]
```

Finding PHI for each coin
```{r}
auto_lm <- function(df, response, alpha = 0.05) {
  # start with all predictors except response and Date
  predictors <- setdiff(names(df), c(response, "Date"))
  
  formula <- as.formula(paste(response, "~", paste(predictors, collapse = " + "), "+ 0"))
  model <- lm(formula, data = df)
  
  repeat {
    pvals <- summary(model)$coefficients[, 4]  # no intercept anymore
    max_p <- max(pvals, na.rm = TRUE)
    
    if (max_p < alpha) break  # stop if all are significant
    
    worst_var <- names(which.max(pvals))
    predictors <- setdiff(predictors, worst_var)
    
    formula <- as.formula(paste(response, "~", paste(predictors, collapse = " + "), "+ 0"))
    model <- lm(formula, data = df)
  }
  
  return(model)
}

tickers = setdiff(colnames(train), "Date")
all_PHI = data.frame(Date = train$Date) # Start off with Dates
all_models = list()


for (i in tickers) {
  temp_model <- auto_lm(train, i, alpha = 0.05)
  
  # Save residuals
  all_PHI[[i]] <- residuals(temp_model)
  
  # Save the full model
  all_models[[i]] <- temp_model
}
  
```

```{r}
# Check data
ggplot(all_PHI, aes(y = BTC, x = Date)) +
  geom_line() +
  geom_hline(yintercept = 0, color="blue")
```


Find AR model parameters
```{r}
coin_ticker = "ADA"



fit <- auto.arima(all_PHI[[coin_ticker]], d = 0, max.p = 1, max.q = 0)

# Coefficients and standard errors
coefs <- fit$coef
se <- sqrt(diag(fit$var.coef))

# t-values and two-sided p-values
tvals <- coefs / se
pvals <- 2 * (1 - pnorm(abs(tvals)))

# Put in a tidy table
results <- data.frame(
  Estimate = coefs,
  Std.Error = se,
  t.value = tvals,
  p.value = pvals
)

results

```
Back test for specific coin from 2020-10-5 to 2021-07-06
```{r}
# Put PHI and Price data in the same df
trading_df = data.frame(test)
model = all_models[[coin_ticker]]

starting_money = 1000
balance = c(starting_money)
sigma_2 = as.numeric(fit$sigma2)
lambda = as.numeric(fit$coef)
coin_coef = -model$coefficients# -1 because you solve you the residual by subtracting lm
coin_coef[[coin_ticker]] = 1
  
for (i in 1:(nrow(trading_df)-1)) { # -1 because you cant trade on last day
  day_data = trading_df[i, ]
  next_day_data = trading_df[i+1, ]
  
  phi = day_data[[coin_ticker]] - predict(model, newdata = day_data)
  
  position_fraction = -(1-lambda)*phi / ( (1-lambda)^2*phi^2+sigma_2 ) # calculated based on E[ln(1-pi)] estimate, not correct

  position_fraction = pmin(pmax(position_fraction, -.9), .9)
  position_value = position_fraction * tail(balance, 1)
  
  exposure = sum(abs(coin_coef) * as.numeric(day_data[names(coin_coef)])) # abs() because cash is needed to hold short
  
  buy_ratio = position_value / exposure
  
  buy_coin_amounts = coin_coef * buy_ratio
  
  price_t0 = 0
  for (j in names(coin_coef)) {
    price_t0 = price_t0 + as.numeric(day_data[j] * buy_coin_amounts[j])
  }
  price_t1 = 0
  for (j in names(coin_coef)) {
    price_t1 = price_t1 + as.numeric(next_day_data[j] * buy_coin_amounts[j])
  }
  profit = price_t1-price_t0
  balance[i+1] = balance[i] + profit
  
}
tail(balance, 10)
min(balance)
max(balance)
```


```{r}
balance_df = data.frame(Date = test$Date, balance = balance)

ggplot(balance_df, aes(y=balance, x=Date)) +
  geom_line()
```








